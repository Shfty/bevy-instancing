TODO: Optimization pass
      * Base indirect buffer can be generated during mesh batching,
        but needs to be duplicated and updated with counts + offsets for each instance batch
        * Per-batch indirect buffers should live as a BufferVec in a resource, update by batch key
      * Instance buffer needs to be updated each frame,
        but can live as a BufferVec in a resource for the sake of reusing GPU primitives

TODO: Specialized binding example for instance compute
      * Double-buffer instances for 3D boids

TODO: Account for uniform buffer size limits
      * Currently only binding one set of UNIFORM_MAX_INSTANCES-length instances
      * Need to split instance batches by max size, spread across extra draw calls
        * Should be transparent to bind group draw functions, direct / indirect draw invocation
          * Thus, needs to be implemented by queueing additional batch entities
            * Will need to split during prepare_batched_instances when indirect / instance data is prepared

TODO: Implement StandardInstancedMaterial
      * Initial goal: Make pbr.wgsl work with instances
        * Should be able to encode most StandardMaterial params as instance data
      * Secondary goal: Make shadows work

FIXME: Instance buffer layout is incorrect under wasm
       * Instances draw, but with incorrect positions
       * Instance buffer appears to be excessively padded
         * Manually drawing instances 0..64 for each indirect reveals that all the transform data is there,
           but at 10-instance-wide intervals instead of the expected 1-instance-wide
         * Experimented with explicitly specifying struct size and alignment, but makes no difference
         * Likely some unaccounted-for wgpu feature or limit

NOTES: Transparency ordering
      * Currently, transparency ordering is only correct versus other instances with the
        same mesh within the same batch
        * This is down to sorting each batch into contiguous blocks of a given mesh,
          then sorting the instances in those blocks by depth
      * It's fundamentally more performant due to scaling by O(mesh_count) calls,
        but also fundamentally incorrect w.r.t. transparency ordering
      * Correctness requires that depth supercedes mesh for sorting purposes
        * Batches could be sorted by depth, and then a series of indirect draw calls
          could be generated for each contiguous block of a given mesh
      * However, is this worth it given that transparency ordering cannot take place across different batches? 
        * With this context, order-independence is the only truly correct solution
        * Intuition says favour performance for now and document technicalities around instanced draw order
          * Mesh / Material key types can control ordering at the type level for user control
          * Only affects transparent objects
          * Extra complexity not worth it for correctness within the same material, but incorrectness vs others

