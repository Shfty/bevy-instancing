FIXME: Flickering at high instance counts
       * Happens independently of storage / uniform buffers
       * Appears to occur when a given mesh has more than N instances
         * Doesn't happen in the test scene if the second set of meshes use duplicate assets

FIXME: Uniform buffer codepath; Indirects with more than MAX_INSTANCE_COUNT * 2 instances are only split once 

FIXME: Non-indexed splitting logic needs to be updated to match indexed equivalent
       * Ideally should find a way to generalize this
         * Instance method on GpuInstances?

FIXME: ViewInstanceData / ViewIndirectData is never pruned
       * Remove view entity entry if it gets removed from the ECS
       * How to prune instance batch data?
         * Need a way to check if any instances exist for a given key,
           then prune if zero

TODO: Specialized binding example for instance compute
      * Double-buffer instances for 3D boids

TODO: Implement StandardInstancedMaterial
      * Initial goal: Make pbr.wgsl work with instances
        * Should be able to encode most StandardMaterial params as instance data
      * Secondary goal: Make shadows work

TODO: Investigate equivalent to babylon.js 'thin instances' functionality
      * Similar to InstanceSlice; a contiguous block of instances that all draw together with no visibility culling
      * Primary use case is wasm, needs a low-overhead solution to instancing in the absence of compute
      * Use a variant of the regular component-based interface
        * Minus the ComputedVisibility?
      * Ideally data should be updated on change to minimize overhead
        * This could benefit regular instances too
        
FIXME: Instance buffer layout is incorrect under wasm
       * Instances draw, but with incorrect positions
       * Instance buffer appears to be excessively padded
         * Manually drawing instances 0..64 for each indirect reveals that all the transform data is there,
           but at unexpectedly wide intervals instead of the expected 1-instance-wide
         * Experimented with explicitly specifying struct size and alignment, but makes no difference
         * Likely some unaccounted-for wgpu limit

NOTES: Transparency ordering
      * Currently, transparency ordering is only correct versus other instances with the
        same mesh within the same batch
        * This is down to sorting each batch into contiguous blocks of a given mesh,
          then sorting the instances in those blocks by depth
      * It's fundamentally more performant due to scaling by O(mesh_count) calls,
        but also fundamentally incorrect w.r.t. transparency ordering
      * Correctness requires that depth supercedes mesh for sorting purposes
        * Batches could be sorted by depth, and then a series of indirect draw calls
          could be generated for each contiguous block of a given mesh
      * However, is this worth it given that transparency ordering cannot take place across different batches? 
        * With this context, order-independence is the only truly correct solution
        * Intuition says favour performance for now and document technicalities around instanced draw order
          * Mesh / Material key types can control ordering at the type level for user control
          * Only affects transparent objects
          * Extra complexity not worth it for correctness within the same material, but incorrectness vs others

